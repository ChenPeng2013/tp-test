package main

import (
	"errors"
	"fmt"
	"github.com/spf13/cobra"
	"github.com/dqinyuan/go-randgen/gendata"
	"github.com/dqinyuan/go-randgen/grammar"
	"github.com/dqinyuan/go-randgen/resource"
	"io/ioutil"
	"log"
	"math"
	"os"
	"strings"
)

var format bool
var breake bool
var zzPath string
var yyPath string
var outPath string
var queries int
var maxRecursive int
var root string
var skipZz bool

var debug bool

var rootCmd = &cobra.Command{
	Use:   "go-randgen",
	Short: "random generate sql with yy and zz like mysql randgen",
	PreRunE: func(cmd *cobra.Command, args []string) error {
		if yyPath == "" {
			return errors.New("yy are required")
		}

		return nil
	},
	Run: randgenAction,
}

// init command flag
func init() {
	rootCmd.PersistentFlags().BoolVarP(&format, "format", "F", true,
		"generate sql that is convenient for reading")
	rootCmd.PersistentFlags().BoolVarP(&breake, "break", "B", false,
		"break zz yy result to two resource")
	rootCmd.PersistentFlags().StringVarP(&zzPath, "zz", "Z",
		"", "zz file path, go randgen have a default zz")
	rootCmd.PersistentFlags().StringVarP(&yyPath, "yy", "Y","", "yy file path, required")
	rootCmd.PersistentFlags().StringVarP(&outPath, "output", "O","output", "sql output file path")
	rootCmd.PersistentFlags().IntVarP(&queries, "queries", "Q", 100, "random sql num generated by zz")
	rootCmd.PersistentFlags().StringVarP(&root, "root", "R", "query", "root bnf expression to generate sqls")

	rootCmd.PersistentFlags().IntVar(&maxRecursive, "maxrecur", 5,
		"yy expression most recursive number, if you want recursive without limit ,set it <= 0")
	rootCmd.PersistentFlags().BoolVar(&debug, "debug", false,
		"print detail generate path")
	rootCmd.PersistentFlags().BoolVar(&skipZz, "skip-zz", false,
		"skip gen data phase, only use yy to generate random sqls")

	rootCmd.AddCommand(newExecCmd())
}

func main() {
	if err := rootCmd.Execute(); err != nil {
		fmt.Println(rootCmd.UsageString())
		os.Exit(1)
	}
}

func getSqls() (ddls []string, sqls []string) {

	var err error
	var keyf gendata.Keyfun

	if !skipZz {
		var zzBs []byte
		if zzPath == "" {
			log.Println("load default zz")
			zzBs, err = resource.Asset("resource/default.zz.lua")
		} else {
			zzBs, err = ioutil.ReadFile(zzPath)
		}

		if err != nil {
			log.Fatalf("load zz fail, %v\n", err)
		}

		zz := string(zzBs)

		ddls, keyf, err = gendata.ByZz(zz)
		if err != nil {
			log.Fatalln(err)
		}
	} else {
		keyf = gendata.NewKeyfun(nil, nil)
	}

	yyBs, err := ioutil.ReadFile(yyPath)
	if err != nil {
		log.Fatalf("load yy from %s fail, %v\n", yyPath, err)
	}

	yy := string(yyBs)


	if maxRecursive <= 0 {
		maxRecursive = math.MaxInt32
	}

	randomSqls, err := grammar.ByYy(yy, queries, root, maxRecursive, keyf, debug)
	if err != nil {
		log.Fatalln("Error: " + err.Error())
	}

	return ddls, randomSqls
}

// generate all sqls and write them into file
func randgenAction(cmd *cobra.Command, args []string) {

	ddls, randomSqls := getSqls()

	if breake {
		if !skipZz {
			err := ioutil.WriteFile(outPath+".data.sql",
				[]byte(strings.Join(ddls, ";\n") + ";"), os.ModePerm)
			if err != nil {
				log.Printf("write ddl in dist fail, %v\n", err)
			}
		}

		err := ioutil.WriteFile(outPath+".rand.sql",
			[]byte(strings.Join(randomSqls, ";\n") + ";"), os.ModePerm)
		if err != nil {
			log.Printf("write random sql in dist fail, %v\n", err)
		}
	} else {
		allSqls := make([]string, 0)
		allSqls = append(allSqls, ddls...)
		allSqls = append(allSqls, randomSqls...)

		err := ioutil.WriteFile(outPath + ".sql",
			[]byte(strings.Join(allSqls, ";\n") + ";"), os.ModePerm)
		if err != nil {
			log.Printf("sql output error, %v\n", err)
		}
	}
}
